<?php
/**
 * Class SessionCookie | ZedBoot/System/Session/SessionCookie.class.php
 * @license     GNU General Public License, version 3
 * @package     System
 * @subpackage  Session
 * @author      Jonathan Hulka <jon.hulka@gmail.com>
 * @copyright   Copyright (c) 2018 Jonathan Hulka
 */

/**
 * Implementation of CookieInterface using DataStores generated by a SessionInterface instance.
 */
namespace ZedBoot\System\Session;
class SessionCookie implements \ZedBoot\System\Session\CookieInterface
{
	protected static
		$gcMax=50; //number of indices to be cleaned up each time a cookie is created or regenerated
	protected
		$loaded=null,
		$id=null,
		$name=null,
		$expireSeconds=null,
		$regenerateSeconds=null,
		$session=null,
		$indexDS=null,
		$error;
	public function getError(){ return $this->error; }
	public function __construct(
		\ZedBoot\System\Session\SessionInterface $session,
		$name,
		$expireSeconds=300,
		$regenerateSeconds=null)
	{
		$this->name=$name;
		$this->expireSeconds=$expireSeconds;
		$this->regenerateSeconds=$regenerateSeconds;
		$this->session=$session;
	}
	
	public function getId($create=true,$regenerate=false)
	{
		$result=false;
		try
		{
			//Ensure that this won't happen on a non-secure connection
			if (!isset($_SERVER['HTTPS']) || $_SERVER['HTTPS'] !== 'on') throw new \Exception('Session insecure: not using HTTPS.');
			if(!$this->loaded || $regenerate)
			{
				$this->load($regenerate);
				if(empty($this->id) && $create) $this->createCookie();
			}
			$result=$this->id;
		}
		catch(\Exception $e)
		{
			error_log($e);
			$this->error=$e->getMessage();
		}
		return $result;
	}
	
	public function reset()
	{
		$result=false;
		$cookie=null;
		$cookieId=null;
		try
		{
			//Ensure that this won't happen on a non-secure connection
			if (!isset($_SERVER['HTTPS']) || $_SERVER['HTTPS'] !== 'on') throw new \Exception('Session insecure: not using HTTPS.');
			if(!empty($_COOKIE[$this->name]))
			{
				$cookieId=$_COOKIE[$this->name];
				//Client has sent a cookie
				if(false===($ds=$this->session->getDataStore($cookieId,$this->expireSeconds,false))) throw new \Exception('System error: Getting cookie datastore.');
				//Just clear the data and let garbage collection deal with it
//Enter cookie CS
				if($ds!==null && !$ds->quickWrite(array())) throw new \Exception('System error: clearing cookie datastore.');
//Exit cookie CS
				$this->setCookie(null,-1);
				$result=true;
			}
			else $result=true;
		}
		catch(\Exception $e)
		{
			error_log($e);
			$this->error=$e->getMessage();
		}
		return $result;
	}
	protected function load($forceRegenerate=false)
	{
		$cookieId=null;
		$cookie=null;
		$internalId=null;
		$now=time();
		$ds=null;
		if(empty($_COOKIE[$this->name]))
		{
			$this->id=null;
		}
		else
		{
			$cookieId=$_COOKIE[$this->name];
			//Client has sent a cookie
			if(false===($ds=$this->session->getDataStore($cookieId,$this->expireSeconds,false))) throw new \Exception('System error: Getting datastore.');
			if($ds===null)
			{
				//Cookie data not found - assume it has expired
				$this->id=null;
			}
			else
			{
//Enter cookie CS
				if(!$ds->lockAndRead($cookie)) throw new \Exception('System error: Could not lock/read cookie data.');
				if(!is_array($cookie)) $cookie=array();
				$internalId=empty($cookie['internalId'])?null:$cookie['internalId'];
				if(empty($internalId) || empty($cookie['accessTime']) || $cookie['accessTime']<($now-$this->expireSeconds))
				{
					//Clear cookie data
					$cookie=array();
					$this->id=null;
				}
				else
				{
					//Cookie is good
					if(
						$forceRegenerate ||
						!empty($this->regenerateSeconds) && $cookie['accessTime']<($now-$this->regenerateSeconds))
					{
						$this->regenerate($cookie['internalId'],$cookieId);
					}
					else $cookie['accessTime']=$now;
					$this->id=$internalId;
				}
				if(!$ds->writeAndUnlock($cookie)) throw new \Exception('System error: Could not write/unlock cookie data.');
//Exit cookie CS
			}
		}
	}
	protected function regenerate($internalId)
	{
		$index=null;
//This is the expensive one: it locks creation of cookies (one at a time for uniqueness)
//Enter index CS (inside original cookie CS)
		$this->lockAndReadIndex($index);
		$this->gc($index);
		$this->helpCreate($internalId,$cookieId,$index);
		$this->writeAndUnlockIndex($index);
//Exit index CS
	}
	protected function createCookie()
	{
		$internalId=null;
		$index=null;
//This is the expensive one: it locks creation of cookies (one at a time for uniqueness)
//Enter index CS
		$this->lockAndReadIndex($index);
		$this->gc($index);
		//Find a unique internal id
		do{ $internalId=$this->getRandom(); }while(array_key_exists($internalId,$index));
		$this->helpCreate($internalId,$index);
		$this->writeAndUnlockIndex($index);
//Exit index CS
		$this->id=$internalId;
	}
	protected function gc(&$index)
	{
		$c=count($index);
		if($c>static::$gcMax)$c=static::$gcMax;
		//remove any expired cookies or cookies missing essential data
		for($i=0;$i<$c;$i++)
		{
			//Get first item off the index
			reset($index);
			$internalId=key($index);
			$cookieId=array_shift($index);
			//Check if datastore still exists
			if(false===($ds=$this->session->getDataStore($cookieId,$this->expireSeconds,false))) throw new \Exception('System error: Checking for expired datastore.');
			//If it is, rotate item to back of index
			if($ds!==null) $index[$internalId]=$cookieId;
		}
	}
	
	/**
	 * Deadlock risk: must only be called from within index CS
	 * This is where cookies are born
	 */
	protected function helpCreate($internalId,&$index)
	{
		$now=time();
		$cookieId=$this->getUnique();
		$index[$internalId]=$cookieId;
		$this->setCookie($cookieId,$now+$this->expireSeconds);
		//Deadlock won't be an issue here because:
		// - This datastore is shown not to exist by getUnique()
		// - It can't have been created in the meantime, since everyone else is locked out
		//Create the datastore
		if(false===($ds=$this->session->getDataStore($cookieId,$this->expireSeconds,true))) throw new \Exception('System error: Creating cookie datastore.');
//Enter new cookie CS (only safe because datastore is guaranteed not previously created)
		if(!$ds->quickWrite(array('accessTime'=>$now, 'internalId'=>$internalId))) throw new \Exception('System error: Writing cookie datastore.');
//Exit new cookie CS
	}
	protected function setCookie($value,$expiry)
	{
		if(!setcookie(
			$this->name, //name
			$value,      //value
			$expiry,     //expiry
			'/',         //path
			getenv('HTTP_HOST'), //domain
			true,        //secure (https only)
			true         //http only (no js)
		)) throw new \Exception('Unable to set cookie. This must happen before output begins.');
		//In case anyone else is interested
		$_COOKIE[$this->name]=$value;
	}
	/**
	 * to guarantee uniqueness, must only be called from within index CS
	 */
	protected function getUnique()
	{
		$result=null;
		$fail=true;
		do
		{
			$result=$this->getRandom();
			//Check for collision (id matches another cookie)
			//collision if datastore exists (try to load with the create option off)
			if(false===($ds=$this->session->getDataStore($result,$this->expireSeconds,false))) throw new \Exception('System error: Checking for collision.');
			//If the datastore was created, it means there was a collision
			//That means the expiry will be erroneously extended on the
			//collided datastore, but given the low probability and extremely
			//low severity(somebody's cookie will last longer than expected
			//if their browser doesn't respect expiry), that will not be a problem
			$fail=$ds!==null;
		} while($fail);
		return $result;
	}
	protected function getRandom()
	{
		$v='';
		$parts=explode('.',$_SERVER['REMOTE_ADDR']);
		foreach($parts as $part) $v.=substr('0'.dechex($part),-2);
//Install random_compat if this breaks
		$v.=random_bytes(48).time();
		return hash('whirlpool',$v);
	}
	protected function lockAndReadIndex(&$data)
	{
		if(false===$this->indexDS=$this->session->getDataStore('000index',0,true)) throw new \Exception('System error: Creating index datastore.');
		if(!$this->indexDS->lockAndRead($data)) throw new \Exception('System error: Locking/reading index datastore.');
		if(!is_array($data)) $data=array();
	}
	protected function writeAndUnlockIndex($data)
	{
		if(!$this->indexDS->writeAndUnlock($data)) throw new \Exception('System error: unlocking index.');
	}
}
