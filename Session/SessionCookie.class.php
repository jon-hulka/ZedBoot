<?php
/**
 * Class SessionCookie | ZedBoot/Session/SessionCookie.class.php
 * @license     GNU General Public License, version 3
 * @package     Session
 * @author      Jonathan Hulka <jon.hulka@gmail.com>
 * @copyright   Copyright (c) 2018 Jonathan Hulka
 */

/**
 * Implementation of CookieInterface using DataStores generated by a SessionInterface instance.
 */
namespace ZedBoot\Session;
use \ZedBoot\Error\ZBError as Err;
class SessionCookie implements \ZedBoot\Session\CookieInterface
{
	protected static
		$gcMax=50; //number of indices to be cleaned up each time a cookie is created or regenerated
	protected
		$loaded=null,
		$id=null,
		$name=null,
		$expireSeconds=null,
		$regenerateSeconds=null,
		$session=null,
		$indexDS=null;
	public function __construct(
		\ZedBoot\Session\SessionInterface $session,
		$name,
		$expireSeconds=300,
		$regenerateSeconds=null)
	{
		$this->name=$name;
		$this->expireSeconds=$expireSeconds;
		$this->regenerateSeconds=$regenerateSeconds;
		$this->session=$session;
	}
	
	public function setClientId($id)
	{
		$_COOKIE[$this->name]=$id;
	}
	
	public function getId($create=true,$regenerate=false)
	{
		//Ensure that this won't happen on a non-secure connection
		if(!(
			(!empty($_SERVER['HTTPS']) && 'off' != $_SERVER['HTTPS']) ||
			(array_key_exists('SERVER_PORT', $_SERVER) && 443 === (int)$_SERVER['SERVER_PORT']) ||
			(array_key_exists('HTTP_X_FORWARDED_SSL', $_SERVER) && 'on' === $_SERVER['HTTP_X_FORWARDED_SSL']) ||
			(array_key_exists('HTTP_X_FORWARDED_PROTO', $_SERVER) && 'https' === $_SERVER['HTTP_X_FORWARDED_PROTO'])
		)) throw new Err('Session insecure: not using HTTPS.');
		if(!$this->loaded || $regenerate)
		{
			$this->load($regenerate);
			if(empty($this->id) && $create) $this->createCookie();
		}
		return $this->id;
	}
	
	public function reset()
	{
		$cookie=null;
		$cookieId=null;
		//Ensure that this won't happen on a non-secure connection
		if(!(
			(!empty($_SERVER['HTTPS']) && 'off' != $_SERVER['HTTPS']) ||
			(array_key_exists('SERVER_PORT', $_SERVER) && 443 === (int)$_SERVER['SERVER_PORT']) ||
			(array_key_exists('HTTP_X_FORWARDED_SSL', $_SERVER) && 'on' === $_SERVER['HTTP_X_FORWARDED_SSL']) ||
			(array_key_exists('HTTP_X_FORWARDED_PROTO', $_SERVER) && 'https' === $_SERVER['HTTP_X_FORWARDED_PROTO'])
		)) throw new Err('Session insecure: not using HTTPS.');
		if(!empty($_COOKIE[$this->name]))
		{
			$cookieId=$_COOKIE[$this->name];
			//Client has sent a cookie
			$ds=$this->session->getDataStore($cookieId,$this->expireSeconds,false);
			//Just clear the data and let garbage collection deal with it
//Enter cookie CS
			if($ds!==null) $ds->quickWrite(null);
//Exit cookie CS
			$this->setCookie(null,-1);
		}
	}
	protected function load($forceRegenerate=false)
	{
		$cookieId=null;
		$cookie=null;
		$internalId=null;
		$now=time();
		$ds=null;
		if(empty($_COOKIE[$this->name]))
		{
			$this->id=null;
		}
		else
		{
			$cookieId=$_COOKIE[$this->name];
			//Client has sent a cookie
			$ds=$this->session->getDataStore($cookieId,$this->expireSeconds,false);
			if($ds===null)
			{
				//Cookie data not found - assume it has expired
				$this->id=null;
			}
			else
			{
//Enter cookie CS
				$cookie=$ds->lockAndRead();
				if(!is_array($cookie)) $cookie=[];
				$internalId=empty($cookie['internalId'])?null:$cookie['internalId'];
				if(empty($internalId) || empty($cookie['accessTime']) || $cookie['accessTime']<($now-$this->expireSeconds))
				{
					//Clear cookie data
					$cookie=[];
					$this->id=null;
				}
				else
				{
					//Cookie is good
					if(
						$forceRegenerate ||
						!empty($this->regenerateSeconds) && $cookie['accessTime']<($now-$this->regenerateSeconds))
					{
						$this->regenerate($cookie['internalId'],$cookieId);
					}
					else $cookie['accessTime']=$now;
					$this->setCookie($cookieId,$now+$this->expireSeconds);
					$this->id=$internalId;
				}
				$ds->writeAndUnlock($cookie);
//Exit cookie CS
			}
		}
	}
	protected function regenerate($internalId)
	{
		$index=null;
//This is the expensive one: it locks creation of cookies (only one created at a time for uniqueness)
//Enter index CS (inside original cookie CS)
		$this->lockAndReadIndex($index);
		$this->gc($index);
		$this->helpCreate($internalId,$cookieId,$index);
		$this->writeAndUnlockIndex($index);
//Exit index CS
	}
	protected function createCookie()
	{
		$internalId=null;
		$index=null;
//This is the expensive one: it locks creation of cookies (one at a time for uniqueness)
//Enter index CS
		$this->lockAndReadIndex($index);
		$this->gc($index);
		//Find a unique internal id
		do{ $internalId=$this->getRandom(); }while(array_key_exists($internalId,$index));
		$this->helpCreate($internalId,$index);
		$this->writeAndUnlockIndex($index);
//Exit index CS
		$this->id=$internalId;
	}
	protected function gc(&$index)
	{
		$c=count($index);
		if($c>static::$gcMax)$c=static::$gcMax;
		//remove any expired cookies or cookies missing essential data
		for($i=0;$i<$c;$i++)
		{
			//Get first item off the index
			reset($index);
			$internalId=key($index);
			$cookieId=array_shift($index);
			//Check if datastore still exists
			$ds=$this->session->getDataStore($cookieId,$this->expireSeconds,false);
			//If it is, rotate item to back of index
			if($ds!==null) $index[$internalId]=$cookieId;
		}
	}
	
	/**
	 * Deadlock risk: must only be called from within index CS
	 * This is where cookies are born
	 */
	protected function helpCreate($internalId,&$index)
	{
//!!!IMPORTANT only call from within index CS
		$now=time();
		$cookieId=$this->getUnique();
		$index[$internalId]=$cookieId;
		$this->setCookie($cookieId,$now+$this->expireSeconds);
		//Deadlock won't be an issue here because:
		// - This datastore is shown not to exist by getUnique()
		// - It can't have been created in the meantime, since everyone else is locked out
		//Create the datastore
		$ds=$this->session->getDataStore($cookieId,$this->expireSeconds,true);
//Enter new cookie CS (only safe because datastore is guaranteed not previously created)
		$ds->quickWrite(['accessTime'=>$now, 'internalId'=>$internalId]);
//Exit new cookie CS
	}
	protected function setCookie($value,$expiry)
	{
		if(!setcookie(
			$this->name, //name
			$value,      //value
			$expiry,     //expiry
			'/',         //path
			getenv('HTTP_HOST'), //domain
			true,        //secure (https only)
			true         //http only (no js)
		)) throw new Err('Unable to set cookie. This must happen before output begins.');
		//In case anyone else is interested
		$_COOKIE[$this->name]=$value;
	}
	/**
	 * to guarantee uniqueness, must only be called from within index CS
	 */
	protected function getUnique()
	{
//!!!IMPORTANT only call from within index CS
		$result=null;
		$fail=true;
		do
		{
			$result=$this->getRandom();
			//Check for collision (id matches another cookie)
			//collision if datastore exists (load with the create option off)
			$ds=$this->session->getDataStore($result,$this->expireSeconds,false);
			//If the datastore already exists, it means there was a collision
			//That means the expiry will be erroneously extended on the
			//collided datastore, but given the low probability and extremely
			//low severity(datastore expiry is extended, but cookie expiry is not),
			//that will not be a problem
			$fail=$ds!==null;
		} while($fail);
		return $result;
	}
	protected function getRandom()
	{
		$v='';
		$parts=explode('.',$_SERVER['REMOTE_ADDR']);
		foreach($parts as $part) $v.=substr('0'.dechex($part),-2);
//Install random_compat if this breaks
		$v.=random_bytes(48).time();
		return hash('whirlpool',$v);
	}
	protected function lockAndReadIndex(&$data)
	{
		$this->indexDS=$this->session->getDataStore('000index',0,true);
		$data=$this->indexDS->lockAndRead();
		if(!is_array($data)) $data=[];
	}
	protected function writeAndUnlockIndex($data)
	{
		$this->indexDS->writeAndUnlock($data);
	}
}
